<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://physics-morris.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://physics-morris.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-25T15:24:05+00:00</updated><id>https://physics-morris.github.io/feed.xml</id><title type="html">Morris Huang</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Test-time training with quantum auto-encoder</title><link href="https://physics-morris.github.io/blog/2024/QTTT/" rel="alternate" type="text/html" title="Test-time training with quantum auto-encoder"/><published>2024-11-11T10:30:00+00:00</published><updated>2024-11-11T10:30:00+00:00</updated><id>https://physics-morris.github.io/blog/2024/QTTT</id><content type="html" xml:base="https://physics-morris.github.io/blog/2024/QTTT/"><![CDATA[<p>Redirecting to another page.</p>]]></content><author><name></name></author><category term="paper"/><summary type="html"><![CDATA[blog post for our paper tackling distribution shift and noisy quantum circuits]]></summary></entry><entry><title type="html">Plasma Two Stream Instability</title><link href="https://physics-morris.github.io/blog/2019/twostream/" rel="alternate" type="text/html" title="Plasma Two Stream Instability"/><published>2019-02-28T00:00:00+00:00</published><updated>2019-02-28T00:00:00+00:00</updated><id>https://physics-morris.github.io/blog/2019/twostream</id><content type="html" xml:base="https://physics-morris.github.io/blog/2019/twostream/"><![CDATA[<h2 id="what-is-two-stream-instability-">What is two stream instability ?</h2> <p>Consider a system comprising two types of fluid, which can be either cold or hot electron beams, moving through a periodic domain with a length of L.</p> <center> <div class="l-page"> <iframe src="/assets/plotly/twostream.html" frameborder="0" scrolling="no" height="300px" width="70%" onerror="this.onerror=null;this.src='/assets/img/twostream/twostream.png';"> </iframe> <noscript> <img src="/assets/img/twostream/twostream.png" height="300px" width="70%"/> </noscript> </div></center> <p>We’ll first derived the linear behavior of the instability then verified the theory by applying Particle-in-Cell simulation which follow closly with 1985 Berkely Plasma Physics via Computer Simulation for more comprehensive derivation.<d-footnote>Berkely Plasma Physics via Computer Simulation.</d-footnote></p> <hr/> <h2 id="theory">Theory</h2> <h3 id="governing-equations">Governing Equations</h3> <p>The system is described using:</p> <ul> <li>Electrostatic wave ↔ Electron motion</li> <li>Vlasov (equation of motion) + Continuity Equation + Poisson’s equation</li> </ul> <p>The fundamental equations are:</p> \[f(x, v, t) = v\] \[\frac{\partial v}{\partial t} + v \frac{\partial v}{\partial x} = - \frac{e}{m_e} E\] \[\frac{\partial n}{\partial t} + \frac{\partial (nv)}{\partial x} = 0\] \[\frac{\partial E}{\partial x} = - \frac{e}{\varepsilon_0} (n - n_0)\] <p>Where:</p> <ul> <li><code class="language-plaintext highlighter-rouge">v</code> is the velocity of the electron fluid,</li> <li><code class="language-plaintext highlighter-rouge">n</code> is the density of the electron fluid,</li> <li><code class="language-plaintext highlighter-rouge">n_0</code> is the density of the ion background.</li> </ul> <h3 id="case-1">Case 1</h3> <p>Consider small perturbations of density, velocity, and field in a stationary background.</p> <p>First, we consider the case where <code class="language-plaintext highlighter-rouge">E0 = 0</code> and <code class="language-plaintext highlighter-rouge">v0 = 0</code>, combine the govern equations and keeping only linear terms we have:</p> \[\frac{\partial v_1}{\partial t} = -\frac{e}{m_e} E_1\] \[\frac{\partial n_1}{\partial t} + n_0 \frac{\partial v_1}{\partial x} = 0\] \[\frac{\partial E_1}{\partial x} = -\frac{e}{\varepsilon_0} n_1\] <p>Then, we assume the traveling wave solution which is proportional to \(e^{i(kx - \omega t)}\). We have:</p> \[i \omega v_1 = -\frac{e}{m_e} E_1\] \[-i \omega n_1 + i n_0 k v_1 = 0\] \[i k E_1 = -\frac{e}{\varepsilon_0} n_1\] <p>We have</p> \[\left( 1 - \frac{n_0 e^2}{\varepsilon_0 m \omega^2} \right) E_1 = 0\] \[\left( 1 - \frac{\omega_p^2}{\omega^2} \right) E_1 = 0\] <p>For a nontrivial solution:</p> \[\omega = \pm \omega_p\] <p>This is consistent with our physical picture, where the electrostatic wave frequency equals the plasma frequency.</p> <h3 id="case-2">Case 2</h3> <p>In another situation where the electron fluid has a velocity (<code class="language-plaintext highlighter-rouge">v0 ≠ 0</code>), the governing equations become:</p> \[\frac{\partial v_1}{\partial t} + v_0 \frac{\partial v_1}{\partial x} = - \frac{e}{m_e} E_1\] \[\frac{\partial n_1}{\partial t} + n_0 \frac{\partial v_1}{\partial x} + v_0 \frac{\partial n_1}{\partial x} = 0\] \[\frac{\partial E_1}{\partial x} = - \frac{e}{\varepsilon_0} n_1\] <p>Assuming a plane wave solution, we have:</p> \[\left[ 1 - \frac{\left( \omega_p^2 / \omega^2 \right) - k v_0}{2} \right] E_1 = 0\] \[\omega = \omega_D \pm \omega_p\] <p>Where \(\omega_D\) represents the Doppler frequency, indicating that the plasma oscillation frequency is shifted by the Doppler effect.</p> <h3 id="combine-case-1-and-2">Combine Case 1 and 2</h3> <p>This scenario consists of two electron fluid species: one relatively stationary to the ion background, and another with velocity \(v_0\). For plasma neutrality, we require:</p> \[n_0 = n_{01} + n_{02}\] <p>The Vlasov and continuity equations are the same as in the previous cases (3) and (8), but Poisson’s equation is coupled together by the two fluids:</p> \[\frac{\partial E_1}{\partial x} = -\frac{e}{\varepsilon_0} (n_{11} + n_{12})\] <p>By substituting \(n_{11}\) and \(n_{12}\) with the Vlasov and continuity equations, we obtain:</p> \[\left[ \frac{n_{01} e^2}{m \varepsilon_0 \omega^2} + \frac{n_{02} e^2}{m \varepsilon_0 (\omega - \omega_D)^2} - 1 \right] E_1 = 0\] <p>Finally, the dispersion relation can be expressed as:</p> \[F(\omega) \equiv \frac{\omega_{p1}^2}{\omega^2} + \frac{\omega_{p2}^2}{(\omega - \omega_D)^2} = 1\] <p>Where \(\omega_{p1}\) and \(\omega_{p2}\) are the plasma frequencies of the two species.</p> <p>For \(\omega_D &gt;&gt; 0\) (right figure)</p> \[F(\omega) = \frac{\omega_{p1}^2}{\omega^2} + \frac{(\omega - \omega_{p2}^2)^2}{(\omega - \omega_D)^2} = 1\] <div class="l-page"> <center> <div class="col-sm-4 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/twostream/b-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/twostream/b-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/twostream/b-1400.webp"/> <img src="/assets/img/twostream/b.jpg" class="img-fluid rounded" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div></center> </div> <p>The solution is \(\omega \approx \pm \omega_{p1} \quad \omega \approx \omega_D \pm \omega_{p2}\)</p> <p>We look for the minimum of \(F\left( \omega \right)\) which happens at</p> \[\omega = \omega_m = \omega_D \left[1 + \left(\frac{\omega_{p2}}{\omega_{p1}}\right)^{2/3}\right] \equiv \omega_D \left(1 + \alpha^{2/3}\right)\] <p>where \(\alpha \equiv \frac{\omega_{p2}}{\omega_{p1}}\)</p> <p>For \(\omega_D \approx 0\)</p> <p>Then the minimum of function \(F\left( \omega \right)\) is</p> \[F_m = F(\omega_m) = \frac{\omega_{p1}^2}{\omega_D^2} \left(1 + \alpha^{2/3}\right)^3\] <div class="l-page"> <center> <div class="col-sm-4 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/twostream/a_new-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/twostream/a_new-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/twostream/a_new-1400.webp"/> <img src="/assets/img/twostream/a_new.jpg" class="img-fluid rounded" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div></center> </div> <p>Let’s assume that \(n_{02} \ll n_{01}\), \(\omega_{p2} \ll \omega_{p1} \quad \text{and} \quad \alpha \ll 1.\)</p> \[F_m \approx \frac{\omega_{p1}^2}{\omega_D^2} \left(1 + 3\alpha^{2/3}\right)\] <p>So then if</p> \[\frac{\omega_{p1}^2}{\omega_D^2} &lt; \left(1 + 3\alpha^{2/3}\right)\text{,} \quad F_m &lt; 1 \quad \Rightarrow \quad 4 \text{ real roots.}\] \[\frac{\omega_{p1}^2}{\omega_D^2} &gt; \left(1 + 3\alpha^{2/3}\right)\text{,} \quad F_m &gt; 1 \quad \Rightarrow \quad 2 \text{ real + 2 complex roots.}\] \[\Rightarrow \quad \omega = \omega_{re} \pm i\omega_{im}\] <p>It will have the solution of \(E \propto e^{i(kx - \omega_{re} t)} e^{\omega_{im} t}\) which grows in time.</p> <p>The instability happened roughly at</p> \[v_f \approx v_0\] <p>When phase velocity is close to fluid velocity, the coupling effect between electrons and wave becomes very strong. With \(v_0\) slightly larger than phase velocity, the energy of the electron is easily transferred to the wave, which results in the positive feedback growth of the electrostatic wave.</p> <h3 id="two-stream-instability">Two stream instability</h3> <p>Instability occurs when \(F(\omega_m) &gt; 1\) when \(\omega_{p1} = \omega_{p2} = \omega_p\) it gives us</p> \[\frac{\omega_p^2}{\omega_D^2} &gt; \frac{1}{8}\] <p>And defining \(\beta \equiv \frac{\omega_D}{\omega_p}\) we have the following instability condition:</p> \[\beta &lt; \sqrt{8}\] <p>Which is verified by directly solving the dispersion relation.</p> \[\frac{\omega_p^2}{\omega^2} + \frac{\omega_p^2}{\left( \omega - \omega_D \right)^2} = 1\] <div class="l-page-outset"> <center> <div class="col-sm-4 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/twostream/growth-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/twostream/growth-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/twostream/growth-1400.webp"/> <img src="/assets/img/twostream/growth.jpg" class="img-fluid rounded" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div></center> </div> <h2 id="simulation">Simulation</h2> <h3 id="temporal-grid">Temporal grid</h3> \[\frac{d\mathbf{r}_i}{dt} = \mathbf{v}_i, \quad \frac{d\mathbf{v}_i}{dt} = - \frac{e}{m_e} \mathbf{E}(\mathbf{r}_i)\] \[\mathbf{E}(\mathbf{x}) = \sum_i \frac{1}{4\pi\epsilon_0} \frac{e}{r_i^2}\] <p>In this scheme we only need two steps to implement this simulation: first find the electric field and then integrate the equation of motion. Combine these two procedures we have formed the temporal grid. However, this process is time-consuming (e.g., for N particles it has the computation complexity of \(\approx 2N + N(N - 1)/2\)).</p> <table> <thead> <tr> <th>Method</th> <th>complexity</th> </tr> </thead> <tbody> <tr> <td>Temporal Grid</td> <td>\(\approx N^2/2 + N\)</td> </tr> <tr> <td>PIC</td> <td>\(4N\)</td> </tr> </tbody> </table> <h3 id="temporal-grid-and-spatial-grid">Temporal grid and Spatial grid</h3> <p>A better way is to simplify the process of calculating the electric field since plasma provides shielding that only the particles within a few nearby Debye cubes are significant. We don’t need all the information of particles to calculate the electric field. Instead, we divide the space into a spatial grid that stores the information regarding density (\(\rho\)), potential (\(\phi\)), and field (\(E\)).</p> <p>In this scenario, we are equivalent to solving the following four equations:</p> \[\frac{d\mathbf{r}_i}{dt} = \mathbf{v}_i, \quad \frac{d\mathbf{v}_i}{dt} = - \frac{e}{m_e} \mathbf{E}(\mathbf{r}_i)\] \[\mathbf{E}(\mathbf{x}) = -\frac{d\phi(\mathbf{x})}{dx}, \quad \frac{d^2\phi(\mathbf{x})}{dx^2} = \frac{e}{\epsilon_0} (n_0 - n(\mathbf{x}))\] <h3 id="temporal-grid-spatial-grid-and-finite-difference">Temporal grid, Spatial grid and Finite difference</h3> <p>Changing the first and second-order ODE into finite difference form:</p> \[\frac{d\mathbf{r}_i}{dt} = \mathbf{v}_i\] \[\frac{d\mathbf{v}_i}{dt} = - \frac{e}{m_e} \mathbf{E}(\mathbf{r}_i)\] \[\mathbf{E}(\mathbf{x}) = -\frac{d\phi(\mathbf{x})}{dx} = \frac{\phi_{j-1} - \phi_{j+1}}{2\Delta x}, \quad \frac{d^2\phi(\mathbf{x})}{dx^2} = \frac{\phi_{j-1} - 2\phi_j + \phi_{j+1}}{(\Delta x)^2} = \frac{e}{\epsilon_0} (n_0 - n(\mathbf{x}))\] <h3 id="first-order-weighting-cic">First order weighting (CIC)</h3> \[q_j = q_c \frac{X_{j+1} - x_i}{\Delta x}, \quad q_{j+1} = q_c \frac{x_i - X_{j}}{\Delta x}\] \[\mathbf{E}(x_i) = \left[ \frac{x_i - X_j}{\Delta x} \right] \mathbf{E}_j + \left[ \frac{x_i - X_j}{\Delta x} \right] \mathbf{E}_{j+1}\] <table> <thead> <tr> <th>Parameter</th> <th>Value</th> </tr> </thead> <tbody> <tr> <td>system length</td> <td>\(2\pi / 0.612 (\lambda_D)\)</td> </tr> <tr> <td>cell length</td> <td>\(0.7 (\lambda_D)\)</td> </tr> <tr> <td>particle per cell</td> <td>\(1,000\)</td> </tr> <tr> <td>beam velocity</td> <td>\(1 (\lambda_D \omega_p)\)</td> </tr> </tbody> </table> <div class="caption"> particle-in-cell simulation parameters </div> <h2 id="code">Code</h2> <p>For demonstration, we will be using JavaScript for this code example of simulating two stream instability. First, let’s initialized some variables and parameters.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">pi</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">atan</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">twopi</span> <span class="o">=</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">atan</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">L</span> <span class="o">=</span> <span class="nx">twopi</span> <span class="o">/</span> <span class="mf">0.6124</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">CL</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">PPC</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">NG</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">NP</span> <span class="o">=</span> <span class="nx">NG</span> <span class="o">*</span> <span class="nx">PPC</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">vb</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nx">L</span> <span class="o">/</span> <span class="mf">15.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">n0</span> <span class="o">=</span> <span class="nx">NP</span> <span class="o">/</span> <span class="nx">L</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">vp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">rho</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">phi</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">E</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">radius</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure> <p>That’s initialized two warm beam or you can first try two cold beam instead.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nf">ini</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">bw</span> <span class="o">=</span> <span class="nx">slider</span><span class="p">.</span><span class="nx">value</span>
    <span class="nx">t</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">()</span>
    <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">()</span>
    <span class="nx">rho</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">()</span>
    <span class="nx">phi</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">()</span>
    <span class="nx">E</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">()</span>
    <span class="c1">// Uniform position of electron</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NP</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nc">GRN</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nx">L</span><span class="p">);</span>
      <span class="nx">r</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">}</span>  
  
  <span class="kd">function</span> <span class="nf">gaussianRandom</span><span class="p">(</span><span class="nx">mean</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nx">stdev</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">();</span> <span class="c1">// Converting [0,1) to (0,1]</span>
      <span class="kd">let</span> <span class="nx">v</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">();</span>
      <span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span> <span class="nx">u</span> <span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">v</span> <span class="p">);</span>
      <span class="c1">// Transform to the desired mean and standard deviation:</span>
      <span class="k">return</span> <span class="nx">z</span> <span class="o">*</span> <span class="nx">stdev</span> <span class="o">+</span> <span class="nx">mean</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="kd">function</span> <span class="nf">GRN</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span><span class="p">)</span> <span class="o">+</span> <span class="nx">min</span><span class="p">;</span>
  <span class="p">}</span></code></pre></figure> <p>The one of four step in one simulation step is calculate the density on the spatial grid as we mention earlier. The following code implement first order weighting method. Remember you must use same order of numerical method when weighting and interpolate the field.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nf">density</span><span class="p">(){</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NG</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">rho</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NP</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">);</span>
      <span class="nx">y</span> <span class="o">=</span> <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">/</span> <span class="nx">dx</span> <span class="o">-</span> <span class="nx">j</span><span class="p">;</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="nx">rho</span><span class="p">[</span><span class="nx">NG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rho</span><span class="p">[</span><span class="nx">NG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nx">y</span><span class="p">)</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="nx">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span><span class="p">{</span>
        <span class="nx">rho</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rho</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nx">y</span><span class="p">)</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="nx">rho</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rho</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NG</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">rho</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rho</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">/</span> <span class="nx">n0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></code></pre></figure> <p>The next step is to calculate the electric field on the grid. Since electric field is just the derivate of potential, this step is rather straighforward.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nf">field</span><span class="p">(){</span>
    <span class="nx">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">phi</span><span class="p">[</span><span class="nx">NG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
    <span class="nx">E</span><span class="p">[</span><span class="nx">NG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">phi</span><span class="p">[</span><span class="nx">NG</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="nx">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NG</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">E</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">phi</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">phi</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></code></pre></figure> <p>Then we need to solve the poisson equation. In my implementation, I use interatively solve the eletric potential with knowing that we are using periodic boundary condition (first grid and the last grid has the same value). Note that this step can have different method of solving, the method introduce here is just one of the most simple one.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nf">Poisson</span><span class="p">(){</span>
    <span class="nx">phi</span><span class="p">[</span><span class="nx">NG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="nx">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NG</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">*</span> <span class="nx">rho</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="nx">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="nx">NG</span><span class="p">;</span>
    <span class="nx">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nx">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NG</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">phi</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rho</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">phi</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nx">phi</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
  
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NG</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">phi</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">phi</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">dx</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></code></pre></figure> <ul> <li>accel Function:</li> </ul> <p>This function calculates the acceleration of a particle at a given position x. It determines the index j of the spatial grid cell the particle is in, based on its position x and grid spacing dx. The acceleration a is computed using linear interpolation of the electric field E. This interpolation considers the electric field at the current (E[j]) and previous (E[j-1]) grid points. Special handling is included for the case when the particle is in the first grid cell (j == 0), where it uses the last (E[NG-1]) and first (E[0]) grid points for interpolation.</p> <ul> <li>leapfrog Function:</li> </ul> <p>This function updates the position r[i] and velocity v[i] of each particle (i) using the Leapfrog integration method. This method is often used in simulations for its stability and accuracy in solving differential equations. accel(r[i]) is called to compute the acceleration for each particle, and then the velocity and position are updated accordingly. The function includes boundary handling to ensure particles remain within the bounds of 0 and L, wrapping around the simulation space if necessary.</p> <ul> <li>halfleap Function:</li> </ul> <p>This function appears to perform a half-step update of the velocities of the particles, again using the accel function for acceleration. This might be part of a larger integration scheme where velocities are updated in half-steps at certain points in the simulation process.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nf">accel</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">x</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">dx</span> <span class="o">-</span> <span class="nx">j</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  
    <span class="k">if </span><span class="p">(</span><span class="nx">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
      <span class="nx">a</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="nx">E</span><span class="p">[</span><span class="nx">NG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nx">y</span><span class="p">)</span> <span class="o">+</span> <span class="nx">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="nx">a</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="nx">E</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nx">y</span><span class="p">)</span> <span class="o">+</span> <span class="nx">E</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">*</span> <span class="nx">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span>
  <span class="p">}</span>
  
  <span class="kd">function</span> <span class="nf">leapfrog</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">vp</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NP</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nf">accel</span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span>
      <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">vp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span>
      <span class="c1">// Check if particle are inside 0 &lt;= x &lt;= L</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">){</span>
        <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">L</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">L</span><span class="p">){</span>
        <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">L</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="kd">function</span> <span class="nf">halfleap</span><span class="p">(){</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NP</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nf">accel</span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">move</code> function in the provided JavaScript code is a key part of a time-stepping procedure in a simulation, likely a Particle-in-Cell (PIC) simulation or similar. This function orchestrates several crucial steps in advancing the state of the system by one time step. Here’s an overview of each step and its role in the simulation:</p> <ol> <li><strong><code class="language-plaintext highlighter-rouge">density()</code></strong>: <ul> <li>This function is presumably responsible for calculating the particle density at each point in the spatial grid. In PIC simulations, particle densities are often calculated by distributing the particles’ contributions to the grid points, a process known as “scatter.”</li> </ul> </li> <li><strong><code class="language-plaintext highlighter-rouge">Poisson()</code></strong>: <ul> <li>This function likely solves the Poisson equation, which is a fundamental equation in electromagnetism. In the context of a PIC simulation, solving the Poisson equation is essential to determine the electric potential given a distribution of charge density (calculated in <code class="language-plaintext highlighter-rouge">density()</code>).</li> </ul> </li> <li><strong><code class="language-plaintext highlighter-rouge">field()</code></strong>: <ul> <li>This function is expected to compute the electric field from the electric potential. In electrostatic PIC simulations, the electric field is typically derived from the gradient of the potential obtained from solving the Poisson equation.</li> </ul> </li> <li><strong><code class="language-plaintext highlighter-rouge">leapfrog()</code></strong>: <ul> <li>As previously described, this function updates the positions and velocities of particles using the Leapfrog integration method. It uses the electric field calculated in <code class="language-plaintext highlighter-rouge">field()</code> to determine the forces on each particle and then updates their states accordingly.</li> </ul> </li> <li><strong><code class="language-plaintext highlighter-rouge">t = t + dt;</code></strong>: <ul> <li>This line increments the simulation time <code class="language-plaintext highlighter-rouge">t</code> by the time step <code class="language-plaintext highlighter-rouge">dt</code>. It’s a crucial part of the time-stepping process, ensuring that the simulation progresses forward in time.</li> </ul> </li> </ol> <p>Overall, the <code class="language-plaintext highlighter-rouge">move</code> function encapsulates a complete update cycle of a simulation step. It integrates various components such as density calculation, solving the Poisson equation, computing the electric field, and updating particle states, which are all essential elements in computational simulations of plasmas or other particle-based systems. This function ensures that each of these components is executed in the correct order, maintaining the integrity of the simulation’s progression over time.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nf">move</span><span class="p">(){</span>
    <span class="nf">density</span><span class="p">();</span>
    <span class="nc">Poisson</span><span class="p">();</span>
    <span class="nf">field</span><span class="p">();</span>
    <span class="nf">leapfrog</span><span class="p">();</span>
    <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span> <span class="o">+</span> <span class="nx">dt</span><span class="p">;</span>
  <span class="p">}</span></code></pre></figure> <h2 id="results">Results</h2> <p>For two opposing moving electron beams with immobile ions as a background the dispersion relation gives: We can then verified that the growth rates of electric field in particular mode accord the theory we derive earlier.</p> \[\frac{\omega_p^2}{\left( \omega + \omega_D \right)^2} + \frac{\omega_p^2}{\left( \omega - \omega_D \right)^2} = 1\] <div class="l-page-outset"> <center> <div class="col-sm-4 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/twostream/mode1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/twostream/mode1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/twostream/mode1-1400.webp"/> <img src="/assets/img/twostream/mode1.png" class="img-fluid rounded" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div></center> </div> <div class="caption"> Eelectric field growth rate. </div> <p>Finally we found out that in PIC simulation, mode with larger wave number are more consistence with theory, compare to small wave number mode which are more prone to competed with different modes in consequence of smaller growth rate than theory predict.</p> <div class="l-page-outset"> <center> <div class="col-sm-4 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/twostream/growth_rate-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/twostream/growth_rate-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/twostream/growth_rate-1400.webp"/> <img src="/assets/img/twostream/growth_rate.png" class="img-fluid rounded" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div></center> </div> <div class="caption"> Compare simulation results with theoretical growth rate. </div>]]></content><author><name>Morris Huang</name></author><category term="physics"/><category term="simulation"/><summary type="html"><![CDATA[Introduction to two stream instability in plasma through code]]></summary></entry></feed>